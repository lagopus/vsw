//
// Copyright 2017-2019 Nippon Telegraph and Telephone Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package pfkey

import (
	"bytes"
	"io"
	"testing"

	"github.com/stretchr/testify/suite"
)

type PFKeyMessageTestSuit struct {
	suite.Suite
	msgMux MsgMux
	sa     sadbAddMsg
}

func Test_PFKeyMessageTestSuite(t *testing.T) {
	ts := new(PFKeyMessageTestSuit)
	ts.msgMux = MsgMuxNew()
	ts.msgMux.ParseHandle(SADB_ADD, &ts.sa)
	suite.Run(t, ts)
}

type sadbAddMsg struct {
	SadbBaseMsg
}

func (s *sadbAddMsg) Parse(r io.Reader) error {
	return s.ParseSadbMsg(r)
}

func (s *sadbAddMsg) Handle(w io.Writer, sadbMsg *SadbMsg) error {
	return nil
}
func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsg() {
	b := []byte{
		0x02,       // version
		0x03,       // type
		0x00,       // errno
		0x00,       // satype
		0x02, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsgWithErr() {
	b := []byte{
		0x01, // version
		0x02, // type
		0x00, // errno
		0x00, // satype
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, nil)

	s.Assert().Error(err)
	s.Assert().Nil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsgWithBaseLenErr() {
	b := []byte{
		0x01, // version
		0x02, // type
		0x00, // errno
		0x00, // satype
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().Error(err)
	s.Assert().Nil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsgWithVersionErr() {
	b := []byte{
		0x01,       // version
		0xff,       // type
		0x00,       // errno
		0x00,       // satype
		0x02, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().Error(err)
	s.Assert().Nil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsgWithNotSupportErr() {
	b := []byte{
		0x02,       // version
		0xff,       // type
		0x00,       // errno
		0x00,       // satype
		0x02, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().Error(err)
	s.Assert().Nil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbBaseMsgWithLenErr() {
	b := []byte{
		0x02,       // version
		0x0f,       // type
		0x00,       // errno
		0x00,       // satype
		0x0a, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().Error(err)
	s.Assert().Nil(smsg)
}

func (s *PFKeyMessageTestSuit) TestparseSadbAddMsg() {

	b := []byte{
		0x02,       // version
		0x03,       // type
		0x00,       // errno
		0x00,       // satype
		0x22, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
		0x02, 0x00, // len 16 octets
		0x01, 0x00, // type 1 SADB_EXT_SA
		0xc8, 0xca, 0xc0, 0x29, // spi
		0x20,                   // replay window
		0x01,                   // state
		0x03,                   // auth
		0x0c,                   // encrypt
		0x00, 0x00, 0x00, 0x00, // sa flags
		0x04, 0x00, // len 32 octets
		0x03, 0x00, // type 3 SADB_EXT_LIFETIME_HARD
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x10, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x04, 0x00, // type 4 SADB_EXT_LIFETIME_SOFT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0xc5, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x02, 0x00, // type 2 SADB_EXT_LIFETIME_CURRENT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x1d, 0x7d, 0x80, 0x58, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x03, 0x00, // len 24 octets
		0x05, 0x00, // type 5 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0c, // addr 172.16.1.12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x06, 0x00, // type 6 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0d, // addr 172.16.1.13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x07, 0x00, // type 7 SADB_EXT_ADDRESS_PROXY
		0xff,       // proto
		0x00,       // prefixlen
		0x00, 0x00, // reserved
		0x02,       // sockaddr len
		0x00, 0x00, // port
		0x00, 0x00, 0x00, 0x00, 0x00, // addr
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x04, 0x00, // len 32 octets
		0x08, 0x00, // type 8 SADB_EXT_KEY_AUTH
		0xa0, 0x00, // bits 160
		0x00, 0x00, // reserved
		0x82, 0x45, 0x2e, 0xb8, 0x73, 0x29, 0xe9, 0x11, 0x11, 0xf8, 0x2c, 0xba, 0x26, 0x86, 0x56, 0xf4, // key
		0xe1, 0x7a, 0xf6, 0x5b, 0x00, 0x00, 0x00, 0x00, // key
		0x03, 0x00, // len 24 octets
		0x09, 0x00, // type 9 SADB_EXT_KEY_ENCRYPT
		0x80, 0x00, // bits 128
		0x00, 0x00, // reserved
		0x34, 0xf4, 0x6b, 0xf2, 0x07, 0x2d, 0x86, 0xb8, 0xf6, 0x74, 0xe8, 0x78, 0x57, 0xd2, 0x0e, 0xe6, // key
		0x02, 0x00, // len 16 octets
		0x13, 0x00, // type 19 SADB_X_EXT_SA2(see https://tools.ietf.org/html/draft-schilcher-mobike-pfkey-extension-00)
		0x02,       // mode 2 IPSEC_MODE_TUNNEL
		0x00,       // reserved
		0x00, 0x00, // reserved
		0x00, 0x00, 0x00, 0x00, // sequence
		0x01, 0x00, 0x00, 0x00, // reqid
	}

	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)

	s.Assert().NotNil(s.sa.Sa)
	s.Assert().NotNil(s.sa.CurrentLifetime)
	s.Assert().NotNil(s.sa.HardLifetime)
	s.Assert().NotNil(s.sa.SoftLifetime)
	s.Assert().NotNil(s.sa.SrcAddress)
	s.Assert().NotNil(s.sa.DstAddress)
	s.Assert().NotNil(s.sa.ProxyAddress)
	s.Assert().NotNil(s.sa.AuthKey)
	s.Assert().NotNil(s.sa.EncKey)
	s.Assert().NotNil(s.sa.SadbXSa2)

}

func (s *PFKeyMessageTestSuit) TestparseSadbAddMsgWithErrPointerPolution() {
	b := []byte{
		0x02,       // version
		0x03,       // type
		0x00,       // errno
		0x00,       // satype
		0x1a, 0x00, // len
		0x00, 0x00, // reserved
		0x2c, 0x00, 0x00, 0x00, // seq
		0xaf, 0x19, 0x00, 0x00, // pid
		0x02, 0x00, // len 16 octets
		0x01, 0x00, // type 1 SADB_EXT_SA
		0xc8, 0xca, 0xc0, 0x29, // spi
		0x20,                   // replay window
		0x01,                   // state
		0x03,                   // auth
		0x0c,                   // encrypt
		0x00, 0x00, 0x00, 0x00, // sa flags
		0x04, 0x00, // len 32 octets
		0x03, 0x00, // type 3 SADB_EXT_LIFETIME_HARD
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x10, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x04, 0x00, // type 4 SADB_EXT_LIFETIME_SOFT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0xc5, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x02, 0x00, // type 2 SADB_EXT_LIFETIME_CURRENT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x1d, 0x7d, 0x80, 0x58, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x03, 0x00, // len 24 octets
		0x05, 0x00, // type 5 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0c, // addr 172.16.1.12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x06, 0x00, // type 6 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0d, // addr 172.16.1.13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x07, 0x00, // type 7 SADB_EXT_ADDRESS_PROXY
		0xff,       // proto
		0x00,       // prefixlen
		0x00, 0x00, // reserved
		0x02,       // sockaddr len
		0x00, 0x00, // port
		0x00, 0x00, 0x00, 0x00, 0x00, // addr
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x01, 0x00,
		0x09, 0x00, // type 9 SADB_EXT_KEY_ENCRYPT
		0x00, 0x00, 0x00, 0x00,
	}
	r := bytes.NewReader(b)
	w := bytes.Buffer{}
	smsg, err := HandlePfkey(r, &w, s.msgMux)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)
	s.Assert().NotNil(s.sa.Sa)
	s.Assert().NotNil(s.sa.CurrentLifetime)
	s.Assert().NotNil(s.sa.HardLifetime)
	s.Assert().NotNil(s.sa.SoftLifetime)
	s.Assert().NotNil(s.sa.SrcAddress)
	s.Assert().NotNil(s.sa.DstAddress)
	s.Assert().NotNil(s.sa.ProxyAddress)
	s.Assert().Nil(s.sa.AuthKey)
	s.Assert().NotNil(s.sa.EncKey)
	s.Assert().Nil(s.sa.Policy)
}
