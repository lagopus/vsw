//
// Copyright 2017-2019 Nippon Telegraph and Telephone Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package receiver

import (
	"bytes"
	"testing"

	"github.com/lagopus/vsw/agents/tunnel/ipsec/pfkey"
	"github.com/lagopus/vsw/vswitch"
	"github.com/stretchr/testify/suite"
)

type PFKeyServerTestSuit struct {
	suite.Suite
	RecieverMsgMux
}

func Test_PFKeyServerTestSuite(t *testing.T) {
	tSuit := PFKeyServerTestSuit{}
	suite.Run(t, &tSuit)
}
func (s *PFKeyServerTestSuit) BeforeTest(suiteName, testName string) {
	s.RecieverMsgMux = NewMsgMuxForVRF(0)
}

func (s *PFKeyServerTestSuit) TestparseSadbAddMsg() {
	b := []byte{
		0x02, 0x00, // len 16 octets
		0x01, 0x00, // type 1 SADB_EXT_SA
		0xc8, 0xca, 0xc0, 0x29, // spi
		0x20,                   // replay window
		0x01,                   // state
		0x03,                   // auth
		0x0c,                   // encrypt
		0x00, 0x00, 0x00, 0x00, // sa flags
		0x04, 0x00, // len 32 octets
		0x03, 0x00, // type 3 SADB_EXT_LIFETIME_HARD
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x10, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x04, 0x00, // type 4 SADB_EXT_LIFETIME_SOFT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0xc5, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x04, 0x00, // len 32 octets
		0x02, 0x00, // type 2 SADB_EXT_LIFETIME_CURRENT
		0x00, 0x00, 0x00, 0x00, // allocations
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // bytes
		0x1d, 0x7d, 0x80, 0x58, 0x00, 0x00, 0x00, 0x00, // addtime
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // usetime
		0x03, 0x00, // len 24 octets
		0x05, 0x00, // type 5 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0c, // addr 172.16.1.12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x06, 0x00, // type 6 SADB_EXT_ADDRESS_SRC
		0x00,       // proto 0 ip
		0x20,       // prefixlen 32 bit
		0x00, 0x00, // reserved
		0x02,       // sockaddr_in len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0d, // addr 172.16.1.13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x03, 0x00, // len 24 octets
		0x07, 0x00, // type 7 SADB_EXT_ADDRESS_PROXY
		0xff,       // proto
		0x00,       // prefixlen
		0x00, 0x00, // reserved
		0x02,       // sockaddr len
		0x00, 0x00, // port
		0x00, 0x00, 0x00, 0x00, 0x00, // addr
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x04, 0x00, // len 32 octets
		0x08, 0x00, // type 8 SADB_EXT_KEY_AUTH
		0xa0, 0x00, // bits 160
		0x00, 0x00, // reserved
		0x82, 0x45, 0x2e, 0xb8, 0x73, 0x29, 0xe9, 0x11, 0x11, 0xf8, 0x2c, 0xba, 0x26, 0x86, 0x56, 0xf4, // key
		0xe1, 0x7a, 0xf6, 0x5b, 0x00, 0x00, 0x00, 0x00, // key
		0x03, 0x00, // len 24 octets
		0x09, 0x00, // type 9 SADB_EXT_KEY_ENCRYPT
		0x80, 0x00, // bits 128
		0x00, 0x00, // reserved
		0x34, 0xf4, 0x6b, 0xf2, 0x07, 0x2d, 0x86, 0xb8, 0xf6, 0x74, 0xe8, 0x78, 0x57, 0xd2, 0x0e, 0xe6, // key
		0x02, 0x00, // len 16 octets
		0x13, 0x00, // type 19 SADB_X_EXT_SA2(see https://tools.ietf.org/html/draft-schilcher-mobike-pfkey-extension-00)
		0x02,       // mode 2 IPSEC_MODE_TUNNEL
		0x00,       // reserved
		0x00, 0x00, // reserved
		0x00, 0x00, 0x00, 0x00, // sequence
		0x01, 0x00, 0x00, 0x00, // reqid
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_ADD]
	err := smsg.Parse(r)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Sa)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
	s.Assert().NotNil(sbmsg.HardLifetime)
	s.Assert().NotNil(sbmsg.SoftLifetime)
}

func (s *PFKeyServerTestSuit) TestparseSadbAddMsgAuthNull() {
	b := []byte{
		0x02, 0x00,
		0x01, 0x00,
		0xc0, 0x5e, 0x1e, 0xdc,
		0x00,
		0x01, // state
		0x00, // auth
		0x0b, // encrypt
		0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, // len 16 octets
		0x13, 0x00, // type 19
		0x02,
		0x00,
		0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, // len 24 octets
		0x05, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x0a, 0x0a, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, // len 24 octets
		0x06, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x0a, 0x0a, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, // len 32 octets
		0x04, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xae, 0x0c, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, // len 32 octets
		0x03, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x78, 0x0f, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x01, 0x00,
		0x09, 0x00, // type 9 SADB_EXT_KEY_ENCRYPT
		0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_ADD]
	err := smsg.Parse(r)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Sa)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
	s.Assert().NotNil(sbmsg.HardLifetime)
	s.Assert().NotNil(sbmsg.SoftLifetime)
}

func (s *PFKeyServerTestSuit) TestparseSadbAddMsgNat() {
	b := []byte{
		0x02, 0x00, 0x01, 0x00, 0xce, 0xc4, 0xe5, 0xb2, 0x20, 0x01, 0x03, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x13, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x02, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x2d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x10, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x09, 0x00, 0x80, 0x00, 0x00, 0x00, 0xca, 0x53, 0xbc, 0x75, 0x47, 0xcb, 0xa9, 0xf5,
		0x64, 0x3a, 0xe4, 0x60, 0x1f, 0x95, 0xac, 0x63, 0x04, 0x00, 0x08, 0x00, 0xa0, 0x00, 0x00, 0x00,
		0xc1, 0x06, 0xaf, 0x5b, 0xba, 0xd7, 0xe9, 0xcb, 0xe0, 0x64, 0xf4, 0x91, 0x20, 0xa1, 0xae, 0x67,
		0x6a, 0x86, 0x63, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x14, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x15, 0x00, 0x11, 0x94, 0x00, 0x00, 0x01, 0x00, 0x16, 0x00, 0x11, 0x94, 0x00, 0x00,
	}
	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_ADD]
	err := smsg.Parse(r)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Sa)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
	s.Assert().NotNil(sbmsg.HardLifetime)
	s.Assert().NotNil(sbmsg.SoftLifetime)
	s.Assert().NotNil(sbmsg.NatTType)
	s.Assert().NotNil(sbmsg.NatTSrcPort)
	s.Assert().NotNil(sbmsg.NatTDstPort)
}

func (s *PFKeyServerTestSuit) TestparseSadbAddMsgWithError() {
	b := []byte{
		0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbAddMsg{}
	err := smsg.Parse(r)

	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbUpdateMsg() {
	b := []byte{
		0x02, 0x00, 0x01, 0x00, 0xc8, 0xca, 0xc0, 0x29, 0x20, 0x01, 0x03, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x10, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xc5, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x1d, 0x7d, 0x80, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x07, 0x00, 0xff, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0xa0, 0x00, 0x00, 0x00,
		0x82, 0x45, 0x2e, 0xb8, 0x73, 0x29, 0xe9, 0x11, 0x11, 0xf8, 0x2c, 0xba, 0x26, 0x86, 0x56, 0xf4,
		0xe1, 0x7a, 0xf6, 0x5b, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x09, 0x00, 0x80, 0x00, 0x00, 0x00,
		0x34, 0xf4, 0x6b, 0xf2, 0x07, 0x2d, 0x86, 0xb8, 0xf6, 0x74, 0xe8, 0x78, 0x57, 0xd2, 0x0e, 0xe6,
		0x02, 0x00, 0x13, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_UPDATE]
	err := smsg.Parse(r)

	s.Assert().NoError(err)
	s.Assert().NotNil(smsg)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbGetSPIMsgReq() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xcf, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_GETSPI]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Sa)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
}

func (s *PFKeyServerTestSuit) TestparseSadbGetSPIMsgReqWithError() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbGetSPIMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbGetMsg() {
	b := []byte{
		0x02, 0x00, 0x01, 0x00, 0xc8, 0xca, 0xc0, 0x29, 0x20, 0x01, 0x03, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_GET]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbGetMsgWithError() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbGetMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbDeleteMsg() {
	b := []byte{
		0x02, 0x00, 0x01, 0x00, 0xc8, 0xca, 0xc0, 0x29, 0x20, 0x01, 0x03, 0x0c, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_DELETE]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Sa)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
}

func (s *PFKeyServerTestSuit) TestparseSadbDeleteMsgWithError() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbDeleteMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDAddMsg() {
	b := []byte{
		0x08, 0x00, // len 64 octets
		0x12, 0x00, // type 18 SADB_X_EXT_POLICY
		0x02, 0x00, // policy type
		0x03,                   // dir
		0x00,                   // reserved
		0x00, 0x00, 0x00, 0x00, // id
		0x7f, 0xda, 0x05, 0x00, // reserved
		0x30, 0x00, // len 48 octets
		0x32, 0x00, // proto 50 ESP
		0x02,       // mode
		0x03,       // level
		0x00, 0x00, // reserved
		0x02, 0x00, 0x00, 0x00, // reqid
		0x00, 0x00, 0x00, 0x00, // reserved
		0x02,       // sockaddr len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0c, // addr 172.16.2.13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x02,       // sockaddr len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0d, // addr 172.16.1.12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //zero
		0x03, 0x00, 0x05, 0x00, 0xff, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xbf, 0xff, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0xff, 0x10, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_X_SPDADD]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Policy)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDAddMsg2() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0xff, 0x18, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0xc8, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0xff, 0x18, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xc0, 0xa8, 0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7e, 0xd5, 0x89, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x12, 0x00, 0x02, 0x00, 0x02, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x43, 0x0b, 0x00, 0x00,
		0x30, 0x00, 0x32, 0x00, 0x02, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_X_SPDADD]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Policy)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDAddMsgWithError() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbXSPDAddMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDUpdateMsg() {
	b := []byte{
		0x08, 0x00, // len 64 octets
		0x12, 0x00, // type 18 SADB_X_EXT_POLICY
		0x02, 0x00, // policy type
		0x03,                   // dir
		0x00,                   // reserved
		0x00, 0x00, 0x00, 0x00, // id
		0x7f, 0xda, 0x05, 0x00, // reserved
		0x30, 0x00, // len 48 octets
		0x32, 0x00, // proto 50 ESP
		0x02,       // mode
		0x03,       // level
		0x00, 0x00, // reserved
		0x02, 0x00, 0x00, 0x00, // reqid
		0x00, 0x00, 0x00, 0x00, // reserved
		0x02,       // sockaddr len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0c, // addr 172.16.2.13
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // zero
		0x02,       // sockaddr len
		0x00,       // family
		0x00, 0x00, // port
		0xac, 0x10, 0x01, 0x0d, // addr 172.16.1.12
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //zero
		0x03, 0x00, 0x05, 0x00, 0xff, 0x10, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xbf, 0xff, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0xff, 0x10, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_X_SPDUPDATE]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Policy)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDUpdateMsgWithError() {
	b := []byte{
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := sadbXSPDUpdateMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDGetMsg() {
	b := []byte{
		0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x80, 0xea, 0x05, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_X_SPDGET]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)

	sbmsg := pfkey.SadbBaseMsg{}
	buf := bytes.NewBuffer(w.Bytes()[pfkey.SadbMsgLen:])
	err = sbmsg.ParseSadbMsg(buf)
	s.Assert().NoError(err)
	s.Assert().NotNil(sbmsg.Policy)
	s.Assert().NotNil(sbmsg.SrcAddress)
	s.Assert().NotNil(sbmsg.DstAddress)
	s.Assert().NotNil(sbmsg.CurrentLifetime)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDGetMsgWithError() {
	b := []byte{
		0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x02,
	}

	r := bytes.NewReader(b)
	smsg := sadbXSPDGetMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDDeleteMsg() {
	b := []byte{
		0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xea, 0x05, 0x00,
		0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0d,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0xac, 0x10, 0x01, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	}

	r := bytes.NewReader(b)
	smsg := s.RecieverMsgMux.MsgMux[pfkey.SADB_X_SPDDELETE]
	err := smsg.Parse(r)
	s.Assert().NotNil(smsg)
	s.Assert().NoError(err)

	w := bytes.Buffer{}
	samsg := pfkey.SadbMsg{}

	err = smsg.Handle(&w, &samsg)
	s.Assert().NoError(err)
	s.Assert().NotNil(w)
}

func (s *PFKeyServerTestSuit) TestparseSadbXSPDDeleteMsgWithError() {
	b := []byte{
		0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x02,
	}

	r := bytes.NewReader(b)
	smsg := sadbXSPDDeleteMsg{}
	err := smsg.Parse(r)
	s.Assert().Error(err)
}

func (s *PFKeyServerTestSuit) TestNewMsgMux() {
	m := NewMsgMux()
	s.Assert().NotNil(m)
}

func (s *PFKeyServerTestSuit) TestNewMsgMuxForVRF() {
	m1 := NewMsgMuxForVRF(1)
	s.Assert().NotNil(m1)
	m2 := NewMsgMuxForVRF(2)
	s.Assert().NotNil(m2)
	var i vswitch.VRFIndex = 1
	for _, v := range m1.MsgMux {
		s.Assert().Equal(i, vrfs.load(v))
	}
	i = 2
	for _, v := range m2.MsgMux {
		s.Assert().Equal(i, vrfs.load(v))
	}
	m1.Free()
	for _, v := range m1.MsgMux {
		_, ok := vrfs.sm.Load(v)
		s.Assert().False(ok)
	}
}
